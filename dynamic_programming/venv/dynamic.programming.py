#fibonacci numbers
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

#print(fib(10))


def fibonacci(n):
    if n in (1, 2):
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)


#print(fibonacci(50))

def fib_while(fib):
    fib1 = 1
    fib2 = 1
    n = fib - 2
    while n > 0:
        fib1, fib2 = fib2, fib1 + fib2
        n -= 1
    return fib2

print(fib_while(50))

#вычисление n-го числа фибоначчи - быстро но не экономит память
#рекурсия тоже не экономит память!!!
def fib_list(n):
    fib = [0, 1] + [0] * (n - 1)
    # [0] * (n-1) - резервирование памяти для массива
    for i in range(2, n+1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib[n]

print(fib_list(10))

# Кузнечик прыгает по прямой. Может прыгнуть на 1 деление
# или на 2 сразу. Сколько вариантов достижения кузнечиком клетки N?
# В клетку N последний прыжок будет либо через 2 клетки (из клетки равной
# N-2), либо через 1 клетку (из клетки равной N-1). И сумма всех вариантов равна
# сумме вариантов с N-2 и c N-1 - то есть сумме чисел фибоначчи.

# Расчот минимальной стоимости пути кузнечика. Пусть за посещение
# каждой i-й клетки есть определённая стоимость priceх[i], а C[i] -
# минимальная стоимость достижения клетки i. Тогда
# C[i] = price[i] + C[i-1] + C[i-2], C[1] = price[1],
# C[2] = price[2]

def count_min_cost(N, price:list):
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (n-2)
    for i in range(3, n+1):
        C[i] = price[i] + min(C[i-1], [i-2])
    return C[N]

#Двумерные массивы
# Неправильное создание списка списков
A = [[0] * 3] * 2
# При таком создании список [0] * 3 не создаётся
# заново, и будут ссылки на один и тот же список.
# И если в один список положыть какое-либо значение,
# оно окажется во всех списках, так как ссылки созданы на один
# и тот же объект
print(A)
A[0][1] = 4
# Получается:
# [[0, 4, 0], [0, 4, 0]]
print(A)
print(A[0] is A[1]) #True
print()
print()
# Правильное создание двумерного массива
# Для этого надо делать генерацыю списка
A = [[0] * 3 for i in range(2)]
print("generated A")
print(A)
print(A[0] is A[1]) #False
print("new A")
A[0][1] = 4 #result: [[0, 4, 0], [0, 0, 0]]
print(A)

# Задачка про шахматного короля.
# каково число траекторий, по которым
# король может перейти из левого верхнего
# угла в правый нижний, если он может
# ходить только вправо и вниз.
# У доски N строк и М столбцов.
# Количество траекторий K[N][M]
# В клетку [i][j] можно попасть либо из
# клетки [i][j-1], либо из клетки [i-1][j]
# Количество способов, которыми можно добраться в клетку
# [i][j], равно количеству способов, которыми можно
# добраться в неё из клетки [i-1][j] плюс кол-во
# способов, которыми можно добраться в неё из клетки
# [i][j-1]: K[i][j] = K[i-1][j] + K[i][j-1].
# Во все клетки первого столбца или первой строки можно попасть
# только одним способом - двигаясь по вертикали или по горизонтали
# соответственно. Таблица количества траекторий:
# 1  1  1   1   1   1
# 1  2  3   4   5   6
# 1  3  6   10  15  21
# 1  4  10  20  35  56
#   1  5  15  35  70  126
#   1  6  21  56  126 252
# Получился повёрнутый на 45 градусов
# треугольник Паскаля.
# Треугольник Паскаля — бесконечная таблица биномиальных коэффициентов,
# имеющая треугольную форму. В этом треугольнике на вершине и по бокам
# стоят единицы. Каждое число равно сумме двух расположенных над ним чисел.


###Наибольшая общая подпоследовательность
# А, В - массивы чисел. N = len(A), M = len(B)
# F[ij] - длина наибольшей подпоследовательности частей
# А и В: A[0:i] - часть А, первые i элементов, B[0:j] -
# часть В, первые j элементов
# F[ij] = 1 + F[i-1,j-1] if a[i] = b[i]
# F[ij] = max(F[i,j-1], F[i-1, j]) if a[i] !=b[j]
def lcs(A, B): #largest common subsequence
    """Возвращает длину наибольшей подпоследовательности"""
    F = [[0] * (len(B)+1) for i in range(len(A)+1)]
    for i in range(1, len(A)+1):
        for j in range(1, len(B)+1):
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])
    return F[-1][-1]

A = [1,2, 4, 45, 89, 75, 12, 34, 33, 2, 4, 7, 8, 8]
B =[10, 4, 8, 23, 45, 12, 2, 15, 17, 18]
print()
print(lcs(A, B))

# Наибольшая возрастающая подпоследовательность
# Вычисляем длину наибольшей возрастающей подпоследовательности
# F[i] - НВП для части A[0:i], заканчивающаяся элементом a[i] (A[i-1])
# F[i] = max F[j] + 1 (j < i, a[i] > a[j])
def gis(A): # greatest increasing subsequence
    F = [0] * (len(A)+1)
    for i in range (1, len(A)+1):
        m = 0 # m - max
        for j in range(1, i): #номер элемента
            if A[i] > A[j] and F[j] > m:
                m = F[j]
        F[i] = m + 1
    return F[len(A)]

# Алгоритм укладки рюкзака
# В рюкзаке нельзя унести больше определёной массы
# Вопрос: какую максимальную стоимость предметов можно унести?

#####Редакцыонное расстояние между строками (алгоритм Левенштейна)
# Ошыбки: 1) потеряли символ
#         2) Вставили лишний
#           3) Перепутали символ
# пример: молоко    N symbols
#         колокол   M symbols
# F[ij] - минимальное редакционное расстояние между срезами строк
# A[:i]  B[:j].
# Ответ: F[NM]
# F[i][j] = F[i-1][j-1] if A[i] == B[j]
# F[i][j] = min(F[i-1][j], F[i][j-1], F[i-1][j-1]) if A[i] != B[j]
# Крайний случай: F[i][0] = i, F[0][j] = j - если одно слово пустое ([]),
# то количество правок равно длине второго слова
# F[0][0] = 0
def levenstein(A, B):
    F = [[(i+j) if i*j == 0 else 0 for j in range(len(B)+1)] for i in range(len(A)+1) ]
    for i in range(1, len(A)+1):
        for j in range(1, len(B)+1):
            if A[i-1] == B[j-1]:
                F[i][j] = F[i-1][j-1]
            else:
                F[i][j] = 1 + min(F[i-1][j], F[i][j-1], F[i-1][j-1])
    return F[len(A)][len(B)]

A = "puma"
B = "cuba"

print()
print(levenstein(A, B))

# Проверка равенства строк
# Можно осуществить с помощью Левенштейна

# Свой алгоритм проверки строк
# 1) Если строки равной длины - они не равны
def equal(str1,str2):
    if len(str1) != len(str2):
        return False
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            return False
    return True
# По ассимптотике этот алгоритм лучше Левенштейна

# A = "puma"
# B = "cuba"
print("equality test:")
print(equal(A, B)) # False

# Поиск подстроки в строке
# Наивный алгоритм
def search_substring(str, sub):
    n = 0
    not_found = "not found"
    for i in range(len(str) - len(sub)):
        if equal(str[i:i+len(sub)], sub): # is str[i:i+len(sub)] == sub
            return i
    return not_found
            # n += 1
    # return n # если надо позицыю в строке, то return i
# n - количество вхождений подстроки

s1 = "catpumadfdgpumadkjgkpumadljgd"
s2="dog"
print()
print("substring:")
print(search_substring(s1, s2))